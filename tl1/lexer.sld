;;; -*- mode: gauche -*-

(define-library (tl1 lexer)
  (export tl1-tokenize)
  (import (scheme base)
          (scheme write)
          (scheme char)
          (tl1 exception))

  (begin
    (define (reverse! lst)
      (let lp ((lst lst) (ans '()))
        (if (null? lst) ans
            (let ((tail (cdr lst)))
              (set-cdr! lst ans)
              (lp tail lst)))))

    (define (skip-while port pred)
      (do ((ch (peek-char port) (peek-char port)))
          ((or (eof-object? ch) (not (pred ch))))
        (read-char port)))

    (define (skip-whitespace port)
      (skip-while port char-whitespace?))

    (define (read-while port pred)
      (call-with-port (open-output-string)
        (lambda(out)
          (do ((ch (peek-char port) (peek-char port)))
              ((or (eof-object? ch) (not (pred ch)))
               (get-output-string out))
            (write-char (read-char port) out)))))

    (define (subsequent-letter? ch)
      (or (char-alphabetic? ch) (char-numeric? ch)))

    (define (digit? ch)
      (or (char-numeric? ch)
          (case ch
            ((#\A #\B #\C #\D #\E #\F #\a #\b #\c #\d #\e #\f) #t)
            (else #f))))

    (define (lex port)
      (skip-whitespace port)
      (let ((ch (peek-char port)))
        (case ch
          ((#\= #\+ #\- #\* #\/ #\# #\, #\( #\) #\< #\> #\[ #\] #\{ #\})
           (read-char port) ch)
          ((#\; #\.) (read-char port) (lex port))
          ((#\:)
           (read-char port)
           (let ((nch (peek-char port)))
             (if (eqv? nch #\=)
                 (begin (read-char port) ':=)
                 #\:)))
          ((#\")
           (read-char port)
           (let* ((str (read-while port (lambda(ch)(not (char=? #\" ch)))))
                  (end (read-char port)))
             (when (eof-object? end)
               (raise-tl1-error "string literal is not closed"))
             str))
          ((#\$)
           (read-char port)
           (let ((num (string->number (read-while port digit?) 16)))
             (unless (>= 255 num) (raise-tl1-error "number is too big" num))
             num))
          ((#\')
           (read-char port)
           (let* ((nch (read-char port))
                  (end (read-char port)))
             (if (char=? end #\')
                 (char->integer nch)
                 (raise-tl1-error "expected quotation mark but" end))))
          ((#\%)
           (read-char port)
           (skip-while port (lambda(ch)(not (char=? ch #\newline))))
           (lex port))
          (else
           (cond
            ((eof-object? ch) ch)
            ((char-numeric? ch)
             (let ((num (string->number (read-while port char-numeric?))))
               (unless (>= 255 num) (raise-tl1-error "number is too big" num))
               num))
            ((char-alphabetic? ch)
             (let ((ident (read-while port subsequent-letter?)))
               (string->symbol (string-downcase ident))))
            (else (raise-tl1-error "Invalid character" ch)))))))

    (define (tl1-tokenize port)
      (let loop ((result '()))
        (let ((token (lex port)))
          (if (eof-object? token)
              (reverse! result)
              (loop (cons token result))))))
    ))
